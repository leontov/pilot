# Вселенная «Колибри»: План реализации фазы 6 (Части I–II)

## 1. Общий обзор архитектуры
- **Цель:** Создать процедурно разворачиваемую «Вселенной Колибри» на базе одного WebGPU/WebGL2 `<canvas>` и связанной с ней «Консоли Завета».
- **Ядро:** Единственный источник истины — WASM-модуль `kolibri_core.wasm`, предоставляющий события, команды и телеметрию.
- **Состав интерфейса:**
  - **Render Orchestrator** (TypeScript): управляет жизненным циклом WebGPU/WebGL сцены, синхронизируется с состоянием, поступающим из ядра.
  - **React State Fabric:** хранит древовидную структуру «звёзд» (канвасов), параметры камеры, карту ресурсов, очередь команд.
  - **Командная шина:** двунаправленный поток сообщений между ядром и интерфейсами (`UniverseCanvas` и `CovenantConsole`).

## 2. Главный рендер-цикл (`renderLoop.ts`)

### 2.1 Ответственности модуля
- Инициализация WebGPU с fallback на WebGL2 при недоступности адаптера.
- Создание и обновление буферов для:
  - позиционирования «звёзд»;
  - матриц камеры и проекции;
  - параметров эффектов (яркость, цвет, связи).
- Планировщик кадров (requestAnimationFrame) с адаптивной частотой (целевое значение — 60 FPS, деградация до 30 при нагрузке).
- Интеграция событий ядра (`UniverseEventStream`): обновление состояния сцены и запуск процедур (например, появление новой звезды).

### 2.2 Шаги и подсистемы цикла
1. **`bootstrapRenderer()`**
   - Запрашивает `navigator.gpu` → создаёт `GPUDevice`.
   - При отказе — переключается на `initWebGL2Context()`.
   - Загружает и компилирует WGSL-шейдеры (или GLSL-перевод).
   - Создаёт рендер-пайплайн (`UniversePipeline`).
2. **`startRenderLoop(stateStore)`**
   - Принимает ссылку на хранилище состояния React.
   - Фиксирует timestamp старта, инициализирует временные буферы.
3. **Цикл кадра (`tick(now)`):**
   - **Сбор команд ядра:** опрашивает `CommandQueue` для структур `UniverseDelta`.
   - **Обновление состояний:** применяет патч (immer) к `UniverseState`, в том числе сплайновые анимации (lerp) для перемещений камер/звёзд.
   - **Реакция на ввод:** обрабатывает события от `InputController` (вращение камеры, zoom, панорамирование).
   - **Обновление GPU-буферов:**
     - `updateStarBuffer()` — позиции, радиус, цвет.
     - `updateLinkBuffer()` — рёбра связей между звёздами.
     - `updateCanvasUniforms()` — параметры активного канваса.
   - **Рендер:**
     - Очистка экрана (градиент космоса, шум по шейдеру).
     - Отрисовка связей → звёзд → эффекта ореола.
     - Если активен «Мир-Канвас», переключение в режим оффскрин-пайплайна и композиция с основным кадром.
   - **Постобработка:** bloom/глоу через WGSL compute pass (опционально на GPU).
   - **Планирование следующего кадра:** `requestAnimationFrame(tick)`.

### 2.3 Подсистемы поддержки
- **`InputController`** (TS):
  - Обрабатывает LMB/PMB/колёсико, тач-жесты.
  - Передаёт нормализованные команды (`ROTATE_CAMERA`, `PAN_CAMERA`).
- **`AnimationScheduler`**:
  - Управляет плавными переходами (ease-in-out) при перелётах к звёздам.
  - Позволяет ядру задавать длительности/кривые.
- **`ResourceManager`**:
  - Кэширует модели/текстуры для миров.
  - Интегрируется с lazy-loading по командам ядра.

## 3. Компонент `CanvasWorld.tsx`

### 3.1 Роль и размещение
- Живёт внутри дерева React и рендерится как часть «Оверлея Мира» при наведении/клике на звезду.
- Не привязан к DOM; работает с OffscreenCanvas/WebGL/WebGPU текстурами, передавая результаты в главный пайплайн.

### 3.2 Интерфейсы и пропсы
```ts
interface CanvasWorldProps {
  worldId: string;
  type: 'chat' | 'knowledge_graph' | 'code' | 'music' | 'custom';
  state: UniverseWorldState; // Структура от ядра с чисто цифровыми данными.
  onEmitCommand: (cmd: UniverseCommand) => void;
}
```
- `state` содержит ссылки на буферы цифр (`Uint8Array`) и метаданные (разрешения, viewport, эффекты).
- `onEmitCommand` позволяет миру возвращать интеракции пользователю (например, отправить сообщение).

### 3.3 Жизненный цикл
1. **Монтирование:**
   - Выделяет `OffscreenCanvas` (или `<canvas>` внутри `useEffect`).
   - Создаёт свой мини-рендерер на WebGPU/WebGL (при необходимости — DOM-рендерер для текстовых слоёв через `bitmapRenderer`).
   - Регистрируется в `UniverseRenderRegistry` для компоновки в основной кадр.
2. **Обновление пропсов:**
   - Сравнивает хэш состояния (`state.version`), применяет дифф.
   - Для типа `chat`: синхронизация текстовых лент, запуск эффекта «пролёта» сообщений.
   - Для `knowledge_graph`: построение вершин/рёбер через layout-алгоритмы (force-directed) — с расчётом на фоне (Web Worker).
   - Для `code`: рендер текста через Signed Distance Field шейдеры, поддержка курсора/selection.
   - Для `music`: аудио-входы → спектр → визуализация через FFT в WASM/AudioWorklet.
3. **Размонтирование:**
   - Отменяет анимации, освобождает GPU-ресурсы, сообщает ядру командой `DESTROY_CANVAS`.

### 3.4 Расширяемость
- Тип `custom` получает от ядра WGSL-фрагменты/настройки и может динамически собирать пайплайн (sandboxed).
- Поддержка композиции нескольких миров в одном `CanvasWorld` (например, split-view).

## 4. API команд между ядром и UI

### 4.1 Каналы связи
- **`KolibriCoreBridge`** — класс-адаптер, завершающий обмен с WASM через SharedArrayBuffer + Atomics.
- **Очереди:**
  - `coreToUiQueue` — события от ядра (push-only для UI).
  - `uiToCoreQueue` — команды пользователя.
- Формат каждого сообщения — чистые десятичные массивы (Uint8Array) с типом и телом, интерпретируемые UI.

### 4.2 Форматы команд
| Команда | Направление | Параметры | Назначение |
| --- | --- | --- | --- |
| `CREATE_CANVAS` | core → UI | `{ id, type, seed, orbit }` | Порождает новую звезду, размещает её на орбите относительно родителя. |
| `UPDATE_CANVAS_STATE` | core → UI | `{ id, payload_hash, data_ptr }` | Передаёт новые данные мира (через shared buffer). |
| `SET_CAMERA_TARGET` | core → UI | `{ targetId, distance, easing }` | Управляет камерой, задаёт фокус. |
| `LINK_CANVAS` | core → UI | `{ from, to, weight }` | Добавляет визуальную связь между мирами. |
| `DELETE_CANVAS` | core → UI | `{ id }` | Удаляет звезду и освобождает ресурсы. |
| `REQUEST_INTERACTION` | UI → core | `{ id, eventType, payload }` | Сообщает ядру о действии пользователя (клик, ввод текста). |
| `SYNC_STATE` | двунаправленная | `{ snapshot_id }` | Инициирует синхронное выравнивание состояния (используется при reconnect). |
| `SET_UNIVERSE_THEME` | core → UI | `{ palette, shader_params }` | Меняет глобальные стили космоса. |
| `HEARTBEAT` | core ↔ UI | `{ timestamp }` | Поддерживает синхронизацию времени и перформанс-метрик. |

### 4.3 Обработка команд
- UI регистрирует обработчики в `UniverseCommandRouter`.
- Команды применяются в строгом порядке, фиксируемом меткой `tick_id`.
- При невозможности выполнить команду UI возвращает ядру `COMMAND_REJECTED` с кодом ошибки.

### 4.4 Пример потока для создания мира чата
1. Пользователь (через консоль) → ядру: `:canvas chat`.
2. Ядро эволюционирует формулу, принимает решение → UI: `CREATE_CANVAS({ id: 'chat-42', type: 'chat', orbit: [0, 0, 5] })`.
3. UI размещает звезду, запускает анимацию появления.
4. Ядро → UI: `SET_CAMERA_TARGET({ targetId: 'chat-42', distance: 2.5, easing: 'quadratic' })`.
5. UI подлетает к звезде, активирует `CanvasWorld` типа `chat`.
6. Пользователь вводит сообщение → UI формирует `REQUEST_INTERACTION({ id: 'chat-42', eventType: 'TEXT_INPUT', payload: digits })`.
7. Ядро отвечает новыми сообщениями через `UPDATE_CANVAS_STATE`.

## 5. Шейдерная подсистема (WGSL)

### 5.1 Библиотека шейдеров
- **`cosmos.wgsl`** — фон: процедурный шум + звёздная пыль (3D simplex noise в цилиндрических координатах).
- **`star.wgsl`** — основной шейдер звёзд: billboard-отрисовка с glow, параметризуется яркостью и спектром.
- **`link.wgsl`** — полупрозрачные линии/потоки данных между мирами, регулируемые по весу связи.
- **`canvas_compositor.wgsl`** — смешение оффскрин-рендеров миров с глубиной и цветокоррекцией.
- **`postprocess_bloom.wgsl`** — compute-проход для размытия ярких участков.

### 5.2 Ресурсы и буферы
- Общий uniform `UniverseUniforms` (матрицы `view`, `projection`, `time`, `theme`).
- Storage buffer `StarBuffer` (позиции, радиусы, цвета, состояние активности).
- Storage buffer `LinkBuffer` (индексы, веса, пульсации).
- Для каждого `CanvasWorld` — собственные texture views, встраиваемые в compositor.

### 5.3 Расширяемость шейдеров
- Ядро может присылать параметры мутирования (например, менять палитру в зависимости от метрик).
- Для типов миров ядро может пересылать кастомные WGSL-фрагменты, которые будут безопасно компилироваться в отдельные пайплайны (проверка whitelist).

## 6. Консольное приложение «Консоль Завета» (Часть II)

### 6.1 Общий обзор архитектуры
- **Цель:** Предоставить текстовую оболочку для прямого взаимодействия с ядром «Колибри», поддерживающую локальный REPL, выполнение сценариев и режим демона.
- **Основные подсистемы:**
  - `main.c` — точка входа, разбор аргументов, запуск соответствующего режима.
  - `repl.c` — цикл интерактивного общения, история команд, форматированный вывод.
  - `script_runner.c` — исполнение KolibriScript-файлов с отчётностью об ошибках.
  - `daemon.c` — сервисный цикл, работающий через сетевой модуль `net.c` (из Фазы 2) для участия в рое.
  - `kolibri_bridge.c` — унифицированный интерфейс вызова функций ядра и обмена десятичными потоками.

### 6.2 Точка входа `main.c`
- **Разбор аргументов:** использование `getopt_long` для обработки флагов `--daemon`, `--script`, `--log-level` и `--config`.
- **Инициализация окружения:**
  - загрузка конфигурации (`kolibri_console.conf`) с параметрами сети, путями `genome.dat`, лимитами истории;
  - настройка подсистем логирования и сигналов (обработка `SIGINT`, `SIGHUP` для корректного завершения и перезагрузки конфигурации).
- **Выбор режима:**
  - без аргументов → запуск REPL;
  - с `--script path` → выполнение файла и выход с кодом результата;
  - с `--daemon` → переход в фоновый режим (демонизация: двойное `fork`, изменение `umask`, перенаправление дескрипторов).

### 6.3 REPL (`repl.c`)
- **Цикл:**
  1. отображение приглашения `kolibri> ` и чтение строки через `readline` (или `ncurses`-обёртку для расширенного UI);
  2. добавление введённой команды в историю (`history_append`, хранение последних N записей в `~/.kolibri/history.dec`);
  3. преобразование пользовательского текста в десятичный поток (Закон Единства) и передача в ядро через `kolibri_bridge_eval`;
  4. получение ответа ядра (десятичный поток), обратное отображение в человекочитаемый вид с сохранением цифровой подписи блоков;
  5. отображение результата, телеметрии (`cycles`, `gas`, `fitness`), предупреждений об изменении генома.
- **Дополнительные возможности:**
  - команды мета-уровня (`:teach`, `:why`, `:canvas`, `:sync`, `:verify`) имеют специализированные обработчики для подсветки и подтверждений;
  - поддержка многострочного ввода (например, определение формул) с индикацией незавершённых блоков.

### 6.4 Исполнение файлов (`script_runner.c`)
- **Загрузка:** чтение файла KolibriScript, валидация заголовка (версия, контрольная сумма), преобразование содержимого в десятичные токены.
- **Поток выполнения:** передача батча команд ядру с отслеживанием прогресса; при ошибке — остановка с указанием строки и контекстного блока.
- **Отчётность:** возврат кодов завершения (`0` — успех, `1` — ошибка сценария, `2` — сбой ядра, `3` — нарушение целостности генома), печать краткого отчёта и сохранение логов в `logs/kolibri_script_*.log`.

### 6.5 Режим демона (`daemon.c`)
- **Демонизация:** отделение от терминала, создание PID-файла (`/var/run/kolibri_console.pid`), настройка системного журнала (`syslog`).
- **Интеграция с `net.c`:**
  - инициализация сетевого стека (UDP-сокеты, криптографические ключи, таблицы соседей);
  - периодическая отправка пакетов `KSP_DISCOVERY`, обработка входящих `MIGRATE_RULE`, `PING`, `SYNC_BLOCK`;
  - репликация генома и журналов команд при подтверждённой целостности (HMAC проверяется до передачи данных в ядро).
- **Обработка очередей:** циклическое извлечение событий из канала ядра (`kolibri_bridge_poll`), маршрутизация их в локальные обработчики или по сети.
- **Мониторинг:** экспозиция статуса через UNIX-сокет (`/run/kolibri_console.sock`), позволяющего локальным инструментам запросить состояние (uptime, количество соседей, хэш последнего блока).

### 6.6 Модуль `kolibri_bridge.c`
- **Назначение:** единый слой абстракции поверх WASM/нативного ядра; обеспечивает синхронные и асинхронные вызовы, контроль целостности цифровых потоков.
- **Функции:**
  - `kolibri_bridge_init(const kolibri_config_t*)` — загрузка ядра, подготовка буферов ввода/вывода;
  - `kolibri_bridge_eval(const dec_stream_t* input, dec_stream_t* output)` — запуск формул и команд;
  - `kolibri_bridge_poll(bridge_event_t* out)` — получение событий (например, уведомлений о новых блоках);
  - `kolibri_bridge_shutdown()` — корректное завершение работы, фиксация состояния генома.
- **Выполнение Законов:** строгая работа только с десятичными массивами, валидация HMAC каждой сессии, логирование всех вызовов для реконструкции рассуждений.

### 6.7 Журналирование и диагностика
- **Десятичные журналы:** все логи записываются в формат `*.dec`, представляющий собой пачки десятичных цифр с заголовком, описывающим контекст (модуль, уровень важности).
- **Аналитика:** встроенная команда `:metrics` отображает статистику REPL (среднее время ответа, количество успешных формул, размер генома), а в режиме демона доступен агрегированный отчёт через сетевой протокол.
- **Визуализация связи с «Вселенной Колибри»:** консоль передаёт события UI о создании или модификации миров (`CONSOLE_EMIT_EVENT`), что позволяет веб-интерфейсу синхронно отражать сессии.

### 6.8 Пошаговый план внедрения Части II
1. Реализовать базовую структуру файлов (`main.c`, `repl.c`, `script_runner.c`, `daemon.c`, `kolibri_bridge.c`, `include/kolibri_console.h`).
2. Настроить сборку в `CMakeLists.txt` и `Makefile`, добавить цель `kolibri_console` с зависимостями от ядра.
3. Реализовать REPL с историей и командой `:verify`, покрыть модульными тестами обработку ввода/вывода.
4. Добавить поддержку исполнения сценариев и обработку кодов ошибок.
5. Интегрировать сетевой стек и режим демона, задокументировать API UNIX-сокета.
6. Написать интеграционные сценарии: REPL ↔ ядро, скрипт ↔ ядро, два демона ↔ обмен формулами.
7. Обновить документацию (`docs/console/README.md`) и синхронизировать события с веб-интерфейсом.

## 7. Интеграция между Частями I и II
- Общий `KolibriCoreBridge` обслуживает и графический UI, и консоль.
- «Консоль Завета» получает текстовые события, но может инициировать команды `CREATE_CANVAS`/`SET_CAMERA_TARGET`.
- Стейт-машина ядра гарантирует, что оба интерфейса остаются согласованными (единый `tick_id`).

## 8. План реализации и зависимости
1. **Прототипирование:**
   - Реализовать `KolibriCoreBridge` с мок-ядром (WASM stub), эмулирующим команды.
   - Создать минимальный render loop с одной звездой и базовыми шейдерами.
2. **Командная шина:**
   - Описать форматы в `docs/protocols/universe_commands.md`.
   - Реализовать сериализацию/десериализацию десятичных потоков.
3. **CanvasWorld базовый:**
   - Поддержка типов `chat` и `knowledge_graph`.
   - Подключение input-контроллеров.
4. **Расширение:**
   - Добавить `code`/`music` типы, интеграцию с AudioWorklet.
   - Реализовать динамическую тему и постобработку.
5. **Тестирование:**
   - E2E-сценарии: создание нескольких миров, перелёт камеры, синхронизация с ядром.
   - Профилирование: удерживать 60 FPS при ≥ 100 звёздах.

## 9. Следующие шаги
- Получить утверждение Первого Архитектора на данный план.
- После одобрения — приступить к реализации прототипов обоих интерфейсов и настройке совместной инфраструктуры.

