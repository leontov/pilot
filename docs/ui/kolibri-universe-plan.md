# Вселенная «Колибри»: План реализации фазы 6 (Часть I)

## 1. Общий обзор архитектуры
- **Цель:** Создать процедурно разворачиваемую «Вселенной Колибри» на базе одного WebGPU/WebGL2 `<canvas>` и связанной с ней «Консоли Завета».
- **Ядро:** Единственный источник истины — WASM-модуль `kolibri_core.wasm`, предоставляющий события, команды и телеметрию.
- **Состав интерфейса:**
  - **Render Orchestrator** (TypeScript): управляет жизненным циклом WebGPU/WebGL сцены, синхронизируется с состоянием, поступающим из ядра.
  - **React State Fabric:** хранит древовидную структуру «звёзд» (канвасов), параметры камеры, карту ресурсов, очередь команд.
  - **Командный шина:** двунаправленный поток сообщений между ядром и интерфейсами (`UniverseCanvas` и `CovenantConsole`).

## 2. Главный рендер-цикл (`renderLoop.ts`)

### 2.1 Ответственности модуля
- Инициализация WebGPU с fallback на WebGL2 при недоступности адаптера.
- Создание и обновление буферов для:
  - позиционирования «звёзд»;
  - матриц камеры и проекции;
  - параметров эффектов (яркость, цвет, связи).
- Планировщик кадров (requestAnimationFrame) с адаптивной частотой (целевое значение — 60 FPS, деградация до 30 при нагрузке).
- Интеграция событий ядра (`UniverseEventStream`): обновление состояния сцены и запуск процедур (например, появление новой звезды).

### 2.2 Шаги и подсистемы цикла
1. **`bootstrapRenderer()`**
   - Запрашивает `navigator.gpu` → создаёт `GPUDevice`.
   - При отказе — переключается на `initWebGL2Context()`.
   - Загружает и компилирует WGSL-шейдеры (или GLSL-перевод).
   - Создаёт рендер-пайплайн (`UniversePipeline`).
2. **`startRenderLoop(stateStore)`**
   - Принимает ссылку на хранилище состояния React.
   - Фиксирует timestamp старта, инициализирует временные буферы.
3. **Цикл кадра (`tick(now)`):**
   - **Сбор команд ядра:** опрашивает `CommandQueue` для структур `UniverseDelta`.
   - **Обновление состояний:** применяет патч (immer) к `UniverseState`, в том числе сплайновые анимации (lerp) для перемещений камер/звёзд.
   - **Реакция на ввод:** обрабатывает события от `InputController` (вращение камеры, zoom, панорамирование).
   - **Обновление GPU-буферов:**
     - `updateStarBuffer()` — позиции, радиус, цвет.
     - `updateLinkBuffer()` — рёбра связей между звёздами.
     - `updateCanvasUniforms()` — параметры активного канваса.
   - **Рендер:**
     - Очистка экрана (градиент космоса, шум по шейдеру).
     - Отрисовка связей → звёзд → эффекта ореола.
     - Если активен «Мир-Канвас», переключение в режим оффскрин-пайплайна и композиция с основным кадром.
   - **Постобработка:** bloom/глоу через WGSL compute pass (опционально на GPU).
   - **Планирование следующего кадра:** `requestAnimationFrame(tick)`.

### 2.3 Подсистемы поддержки
- **`InputController`** (TS):
  - Обрабатывает LMB/PMB/колёсико, тач-жесты.
  - Передаёт нормализованные команды (`ROTATE_CAMERA`, `PAN_CAMERA`).
- **`AnimationScheduler`**:
  - Управляет плавными переходами (ease-in-out) при перелётах к звёздам.
  - Позволяет ядру задавать длительности/кривые.
- **`ResourceManager`**:
  - Кэширует модели/текстуры для миров.
  - Интегрируется с lazy-loading по командам ядра.

## 3. Компонент `CanvasWorld.tsx`

### 3.1 Роль и размещение
- Живёт внутри дерева React и рендерится как часть «Оверлея Мира» при наведении/клике на звезду.
- Не привязан к DOM; работает с OffscreenCanvas/WebGL/WebGPU текстурами, передавая результаты в главный пайплайн.

### 3.2 Интерфейсы и пропсы
```ts
interface CanvasWorldProps {
  worldId: string;
  type: 'chat' | 'knowledge_graph' | 'code' | 'music' | 'custom';
  state: UniverseWorldState; // Структура от ядра с чисто цифровыми данными.
  onEmitCommand: (cmd: UniverseCommand) => void;
}
```
- `state` содержит ссылки на буферы цифр (`Uint8Array`) и метаданные (разрешения, viewport, эффекты).
- `onEmitCommand` позволяет миру возвращать интеракции пользователю (например, отправить сообщение).

### 3.3 Жизненный цикл
1. **Монтирование:**
   - Выделяет `OffscreenCanvas` (или `<canvas>` внутри `useEffect`).
   - Создаёт свой мини-рендерер на WebGPU/WebGL (при необходимости — DOM-рендерер для текстовых слоёв через `bitmapRenderer`).
   - Регистрируется в `UniverseRenderRegistry` для компоновки в основной кадр.
2. **Обновление пропсов:**
   - Сравнивает хэш состояния (`state.version`), применяет дифф.
   - Для типа `chat`: синхронизация текстовых лент, запуск эффекта «пролёта» сообщений.
   - Для `knowledge_graph`: построение вершин/рёбер через layout-алгоритмы (force-directed) — с расчётом на фоне (Web Worker).
   - Для `code`: рендер текста через Signed Distance Field шейдеры, поддержка курсора/selection.
   - Для `music`: аудио-входы → спектр → визуализация через FFT в WASM/AudioWorklet.
3. **Размонтирование:**
   - Отменяет анимации, освобождает GPU-ресурсы, сообщает ядру командой `DESTROY_CANVAS`.

### 3.4 Расширяемость
- Тип `custom` получает от ядра WGSL-фрагменты/настройки и может динамически собирать пайплайн (sandboxed).
- Поддержка композиции нескольких миров в одном `CanvasWorld` (например, split-view).

## 4. API команд между ядром и UI

### 4.1 Каналы связи
- **`KolibriCoreBridge`** — класс-адаптер, завершающий обмен с WASM через SharedArrayBuffer + Atomics.
- **Очереди:**
  - `coreToUiQueue` — события от ядра (push-only для UI).
  - `uiToCoreQueue` — команды пользователя.
- Формат каждого сообщения — чистые десятичные массивы (Uint8Array) с типом и телом, интерпретируемые UI.

### 4.2 Форматы команд
| Команда | Направление | Параметры | Назначение |
| --- | --- | --- | --- |
| `CREATE_CANVAS` | core → UI | `{ id, type, seed, orbit }` | Порождает новую звезду, размещает её на орбите относительно родителя. |
| `UPDATE_CANVAS_STATE` | core → UI | `{ id, payload_hash, data_ptr }` | Передаёт новые данные мира (через shared buffer). |
| `SET_CAMERA_TARGET` | core → UI | `{ targetId, distance, easing }` | Управляет камерой, задаёт фокус. |
| `LINK_CANVAS` | core → UI | `{ from, to, weight }` | Добавляет визуальную связь между мирами. |
| `DELETE_CANVAS` | core → UI | `{ id }` | Удаляет звезду и освобождает ресурсы. |
| `REQUEST_INTERACTION` | UI → core | `{ id, eventType, payload }` | Сообщает ядру о действии пользователя (клик, ввод текста). |
| `SYNC_STATE` | двунаправленная | `{ snapshot_id }` | Инициирует синхронное выравнивание состояния (используется при reconnect). |
| `SET_UNIVERSE_THEME` | core → UI | `{ palette, shader_params }` | Меняет глобальные стили космоса. |
| `HEARTBEAT` | core ↔ UI | `{ timestamp }` | Поддерживает синхронизацию времени и перформанс-метрик. |

### 4.3 Обработка команд
- UI регистрирует обработчики в `UniverseCommandRouter`.
- Команды применяются в строгом порядке, фиксируемом меткой `tick_id`.
- При невозможности выполнить команду UI возвращает ядру `COMMAND_REJECTED` с кодом ошибки.

### 4.4 Пример потока для создания мира чата
1. Пользователь (через консоль) → ядру: `:canvas chat`.
2. Ядро эволюционирует формулу, принимает решение → UI: `CREATE_CANVAS({ id: 'chat-42', type: 'chat', orbit: [0, 0, 5] })`.
3. UI размещает звезду, запускает анимацию появления.
4. Ядро → UI: `SET_CAMERA_TARGET({ targetId: 'chat-42', distance: 2.5, easing: 'quadratic' })`.
5. UI подлетает к звезде, активирует `CanvasWorld` типа `chat`.
6. Пользователь вводит сообщение → UI формирует `REQUEST_INTERACTION({ id: 'chat-42', eventType: 'TEXT_INPUT', payload: digits })`.
7. Ядро отвечает новыми сообщениями через `UPDATE_CANVAS_STATE`.

## 5. Шейдерная подсистема (WGSL)

### 5.1 Библиотека шейдеров
- **`cosmos.wgsl`** — фон: процедурный шум + звёздная пыль (3D simplex noise в цилиндрических координатах).
- **`star.wgsl`** — основной шейдер звёзд: billboard-отрисовка с glow, параметризуется яркостью и спектром.
- **`link.wgsl`** — полупрозрачные линии/потоки данных между мирами, регулируемые по весу связи.
- **`canvas_compositor.wgsl`** — смешение оффскрин-рендеров миров с глубиной и цветокоррекцией.
- **`postprocess_bloom.wgsl`** — compute-проход для размытия ярких участков.

### 5.2 Ресурсы и буферы
- Общий uniform `UniverseUniforms` (матрицы `view`, `projection`, `time`, `theme`).
- Storage buffer `StarBuffer` (позиции, радиусы, цвета, состояние активности).
- Storage buffer `LinkBuffer` (индексы, веса, пульсации).
- Для каждого `CanvasWorld` — собственные texture views, встраиваемые в compositor.

### 5.3 Расширяемость шейдеров
- Ядро может присылать параметры мутирования (например, менять палитру в зависимости от метрик).
- Для типов миров ядро может пересылать кастомные WGSL-фрагменты, которые будут безопасно компилироваться в отдельные пайплайны (проверка whitelist).

## 6. Интеграция с «Консолью Завета»
- Общий `KolibriCoreBridge` обслуживает и графический UI, и консоль.
- «Консоль Завета» получает текстовые события, но может инициировать команды `CREATE_CANVAS`/`SET_CAMERA_TARGET`.
- Стейт-машина ядра гарантирует, что оба интерфейса остаются согласованными (единый `tick_id`).

## 7. План реализации и зависимости
1. **Прототипирование:**
   - Реализовать `KolibriCoreBridge` с мок-ядром (WASM stub), эмулирующим команды.
   - Создать минимальный render loop с одной звездой и базовыми шейдерами.
2. **Командная шина:**
   - Описать форматы в `docs/protocols/universe_commands.md`.
   - Реализовать сериализацию/десериализацию десятичных потоков.
3. **CanvasWorld базовый:**
   - Поддержка типов `chat` и `knowledge_graph`.
   - Подключение input-контроллеров.
4. **Расширение:**
   - Добавить `code`/`music` типы, интеграцию с AudioWorklet.
   - Реализовать динамическую тему и постобработку.
5. **Тестирование:**
   - E2E-сценарии: создание нескольких миров, перелёт камеры, синхронизация с ядром.
   - Профилирование: удерживать 60 FPS при ≥ 100 звёздах.

## 8. Следующие шаги
- Получить утверждение Первого Архитектора на данный план.
- После одобрения — перейти к детальной спецификации «Консоли Завета» (Часть II) и реализации прототипов.

